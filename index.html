<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>åª›åª›å¥½è®¢åˆ¶ - èŠ‚ç‚¹ JSON/YAML è½¬å°ç«ç®­å•è¡Œå¯¼å‡ºå·¥å…·ï¼ˆæ”¯æŒæ‰¹é‡ï¼‰</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      color: #fff;
      overflow-x: hidden;
      background: linear-gradient(270deg, #ff4e50, #fc913a, #f9d423, #ede574, #e1f5c4);
      background-size: 1000% 1000%;
      animation: backgroundShift 20s ease infinite;
    }
    @keyframes backgroundShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .container {
      max-width: 950px;
      margin: auto;
      background: rgba(0,0,0,0.6);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 6px 25px rgba(0,0,0,0.5);
      position: relative;
      z-index: 1;
    }
    h1 {
      text-align: center;
      font-size: 40px;
      font-weight: bold;
      background: linear-gradient(90deg, #ff6a00, #ee0979, #ff6a00);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shine 3s linear infinite;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(255,255,255,0.6);
    }
    @keyframes shine {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    label { display: block; margin-top: 15px; font-weight: bold; color: #eee; }
    textarea, input, select {
      width: 100%; padding: 12px; margin-top: 8px;
      border-radius: 10px; border: 1px solid #666;
      font-family: monospace; font-size: 14px; box-sizing: border-box;
      background: rgba(255,255,255,0.9); color: #000;
    }
    button {
      display: inline-block; width: 48%; margin-top: 20px;
      padding: 14px; border: none;
      background: linear-gradient(135deg, #ff416c, #ff4b2b);
      color: white; font-size: 16px; font-weight: bold;
      border-radius: 12px; cursor: pointer; transition: 0.3s; text-align: center;
    }
    button:hover { transform: scale(1.05); }
    .clear-btn { background: linear-gradient(135deg, #8e2de2, #4a00e0); }
    .output { margin-top: 25px; background: rgba(255,255,255,0.9); padding: 20px; border-radius: 12px; color: #000; }
    textarea#output, textarea#batchOutput { border: none; resize: none; }
    .copy-btn { margin-top: 10px; padding: 8px; width: 100%; border: none; border-radius: 8px; background-color: #2196F3; color: #fff; font-size: 14px; cursor: pointer; transition: 0.3s; }
    .copy-btn:hover { background-color: #1976D2; }
    #preview, #batchPreview { margin-top: 20px; padding: 15px; border-radius: 10px; background: #222; border: 1px solid #444; font-family: monospace; font-size: 14px; white-space: pre-line; color: #0f0; }
    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
</head>
<body>
  <canvas id="starfield"></canvas>
  <div class="container">
    <h1>âœ¨ åª›åª›å¥½è®¢åˆ¶ âœ¨</h1>
    <p style="text-align:center;color:#ddd">ä¸“å±éœ¸æ°”é—ªäº®å·¥å…· Â· JSON/YAML èŠ‚ç‚¹ä¸€é”®è½¬å°ç«ç®­</p>

    <label>å•ä¸ªèŠ‚ç‚¹ JSON æˆ– YAML è¾“å…¥ï¼š</label>
    <textarea id="inputText" rows="10" placeholder='ç²˜è´´ JSON æˆ– YAML å•ä¸ªèŠ‚ç‚¹é…ç½®...'></textarea>

    <label>åè®®ç±»å‹ï¼ˆå¯ç•™ç©ºè‡ªåŠ¨è¯†åˆ«ï¼‰ï¼š</label>
    <select id="protocol">
      <option value="">è‡ªåŠ¨è¯†åˆ«</option>
      <option value="vless">VLESS</option>
      <option value="vmess">VMess</option>
      <option value="trojan">Trojan</option>
      <option value="ss">Shadowsocks</option>
      <option value="hy2">Hysteria2</option>
    </select>

    <label>æ‰‹åŠ¨ä¿®æ”¹èŠ‚ç‚¹å¤‡æ³¨åï¼ˆå¯é€‰ï¼‰ï¼š</label>
    <input id="customTag" type="text" placeholder="ä¾‹å¦‚ï¼šç¾å›½-01 | æ‰‹åŠ¨ä¿®æ”¹" />

    <div class="btn-group">
      <button onclick="processInput()">âœ¨ ç”Ÿæˆå•ä¸ªèŠ‚ç‚¹</button>
      <button class="clear-btn" onclick="clearAll()">ğŸ§¹ æ¸…é™¤å†…å®¹</button>
    </div>

    <div id="preview" style="display:none;"></div>

    <div class="output">
      <label>è¾“å‡ºç»“æœï¼ˆå•ä¸ªï¼‰ï¼š</label>
      <textarea id="output" rows="4" readonly></textarea>
      <button class="copy-btn" onclick="copyOutput('output')">ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
    </div>

    <hr style="border:1px solid #666;margin:30px 0;">

    <label>æ‰¹é‡ YAML/JSON èŠ‚ç‚¹è¾“å…¥ï¼š</label>
    <textarea id="batchInput" rows="10" placeholder='ç²˜è´´å¤šä¸ª YAML/JSON èŠ‚ç‚¹é…ç½®...ï¼ˆæ”¯æŒ - {...} åˆ—è¡¨/å¤šè¡Œ JSON/YAMLï¼‰'></textarea>

    <div class="btn-group">
      <button onclick="processBatch()">ğŸš€ æ‰¹é‡è½¬æ¢</button>
      <button class="clear-btn" onclick="clearBatch()">ğŸ§¹ æ¸…é™¤æ‰¹é‡</button>
    </div>

    <div class="output">
      <label>è¾“å‡ºç»“æœï¼ˆæ‰¹é‡ï¼‰ï¼š</label>
      <textarea id="batchOutput" rows="10" readonly></textarea>
      <button class="copy-btn" onclick="copyOutput('batchOutput')">ğŸ“‹ å¤åˆ¶å…¨éƒ¨ç»“æœ</button>
    </div>

    <div id="batchPreview" style="display:none;"></div>
  </div>

  <script>
    // ============ æ˜Ÿç©º + é¼ æ ‡ç²’å­ ============
    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const stars = [];
    for (let i=0;i<140;i++){
      stars.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r: Math.random()*1.8+0.2,
        d: Math.random()*1.2+0.2
      });
    }

    const particles = []; // é¼ æ ‡ç²’å­

    document.addEventListener('mousemove', (e)=>{
      for (let i=0;i<3;i++){
        particles.push({
          x: e.clientX + (Math.random()-0.5)*8,
          y: e.clientY + (Math.random()-0.5)*8,
          dx: (Math.random()-0.5)*1.6,
          dy: (Math.random()-0.5)*1.6 - 0.5,
          life: 50 + Math.floor(Math.random()*40),
          r: 1 + Math.random()*2,
          hue: Math.floor(Math.random()*360)
        });
      }
    });

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // stars
      stars.forEach(s=>{
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.shadowBlur = 12;
        ctx.shadowColor = 'rgba(255,255,255,0.9)';
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        s.y += s.d;
        if (s.y > canvas.height) { s.y = 0; s.x = Math.random()*canvas.width; }
      });

      // particles
      for (let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        ctx.beginPath();
        ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${Math.max(0,p.life/80)})`;
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
        p.x += p.dx;
        p.y += p.dy;
        p.life--;
        if (p.life <= 0) particles.splice(i,1);
      }

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // ============ è¾…åŠ© base64 / è§£æå‡½æ•° ============
    function safeB64Decode(s){
      // æ”¯æŒ url-safe base64
      try {
        s = s.replace(/-/g,'+').replace(/_/g,'/');
        while (s.length % 4) s += '=';
        return decodeURIComponent(escape(atob(s)));
      } catch(e){
        try { return atob(s); } catch(e2) { return s; }
      }
    }
    function safeB64Encode(s){
      try {
        return btoa(unescape(encodeURIComponent(s)));
      } catch(e) {
        return btoa(s);
      }
    }

    // ä» ss:// æˆ–å…¶ä»–é“¾æ¥åè§£ææˆå¤šè¡Œå­—ç¬¦ä¸²ï¼ˆç”¨äº previewï¼‰
    function parseNodeFromURL(url) {
      if (!url) return '';
      try {
        if (url.startsWith('ss://')) {
          // æ”¯æŒä¸¤ç§å¸¸è§æ ¼å¼ï¼š
          // 1) ss://BASE@host:port#tag  (BASE = base64(method:password) )
          // 2) ss://BASE  (BASE è§£ç åä¸º method:password@host:port æˆ–åŒ…å« plugin)
          const withoutPrefix = url.slice(5);
          const hashSplit = withoutPrefix.split('#');
          const tag = decodeURIComponent(hashSplit[1] || '') || 'æœªå‘½åèŠ‚ç‚¹';
          const main = hashSplit[0];

          let userinfoEnc, hostPart;
          if (main.includes('@')) {
            // pattern: BASE@host:port[/?plugin=...]
            [userinfoEnc, hostPart] = main.split('@');
          } else {
            // pattern: BASE  (BASE è§£ç ååŒ…å« userinfo@host:port)
            userinfoEnc = main;
            const decoded = safeB64Decode(userinfoEnc);
            const atIdx = decoded.indexOf('@');
            if (atIdx === -1) return url; // æ— æ³•è§£æ
            userinfoEnc = safeB64Encode(decoded.slice(0, atIdx)); // encode back to base64-ish for parsing
            hostPart = decoded.slice(atIdx+1);
          }

          const userinfo = safeB64Decode(userinfoEnc);
          const colonIdx = userinfo.indexOf(':');
          const method = colonIdx>=0 ? userinfo.slice(0,colonIdx) : '';
          const password = colonIdx>=0 ? userinfo.slice(colonIdx+1) : '';

          // hostPart å¯èƒ½åŒ…å« /?plugin=...
          let server = hostPart;
          let port = '';
          let plugin = '';
          if (hostPart.includes('/?')) {
            const [hostPort, query] = hostPart.split('/?');
            server = hostPort.split(':')[0] || '';
            port = hostPort.split(':')[1] || '';
            // query å¯èƒ½æ˜¯ plugin=xxx%3Bopts...
            if (query.startsWith('plugin=')) {
              const pluginRaw = decodeURIComponent(query.slice(7));
              const [pname, ...opts] = pluginRaw.split(';');
              plugin = pname + (opts.length ? ';' + opts.join(';') : '');
            }
          } else {
            server = hostPart.split(':')[0] || '';
            port = hostPart.split(':')[1] || '';
            // ä¹Ÿå¯èƒ½å«æœ‰ ?å‚æ•°
            if (port && port.includes('?')) {
              port = port.split('?')[0];
            }
          }

          return `åç§°: ${tag}\nåè®®: ss\næœåŠ¡å™¨: ${server}\nç«¯å£: ${port}\nåŠ å¯†: ${method}\nå¯†ç : ${password}${plugin?'\næ’ä»¶: '+plugin:''}`;
        }

        // vmess: è§£ base64 JSONï¼ˆå°½é‡å±•ç¤ºå¸¸ç”¨å­—æ®µï¼‰
        if (url.startsWith('vmess://')) {
          const b = url.slice(8);
          const json = safeB64Decode(b);
          try {
            const obj = JSON.parse(json);
            return `åç§°: ${obj.ps || ''}\nåè®®: vmess\næœåŠ¡å™¨: ${obj.add || ''}\nç«¯å£: ${obj.port || ''}\nUUID: ${obj.id || ''}\né¢å¤–ID: ${obj.aid || ''}\nä¼ è¾“: ${obj.net || ''}\nè·¯å¾„: ${obj.path || ''}\nTLS: ${obj.tls || ''}`;
          } catch(e){
            return url;
          }
        }

        // vless: è§£æ query
        if (url.startsWith('vless://')) {
          const rest = url.slice(8);
          // pattern: vless://uuid@host:port?k=v&..#tag
          const hashIdx = rest.indexOf('#');
          const tag = hashIdx>=0 ? decodeURIComponent(rest.slice(hashIdx+1)) : '';
          const qIdx = rest.indexOf('?');
          const main = qIdx>=0 ? rest.slice(0,qIdx) : (hashIdx>=0 ? rest.slice(0,hashIdx) : rest);
          const afterQ = qIdx>=0 ? (hashIdx>=0 ? rest.slice(qIdx+1,hashIdx) : rest.slice(qIdx+1)) : '';
          const hostPart = main.split('@')[1] || '';
          const host = hostPart.split(':')[0] || '';
          const port = hostPart.split(':')[1] || '';
          const params = {};
          if (afterQ) {
            afterQ.split('&').forEach(p=>{
              const kv = p.split('=');
              if (kv[0]) params[kv[0]] = kv[1] || '';
            });
          }
          return `åç§°: ${tag}\nåè®®: vless\næœåŠ¡å™¨: ${host}\nç«¯å£: ${port}\nUUID: ${main.split('@')[0]}\nå‚æ•°: ${Object.keys(params).length?JSON.stringify(params):''}`;
        }

        // trojan
        if (url.startsWith('trojan://')) {
          const rest = url.slice(9);
          const hashIdx = rest.indexOf('#');
          const tag = hashIdx>=0 ? decodeURIComponent(rest.slice(hashIdx+1)) : '';
          const main = hashIdx>=0 ? rest.slice(0,hashIdx) : rest;
          const atIdx = main.indexOf('@');
          const password = atIdx>=0 ? main.slice(0,atIdx) : '';
          const hostPart = atIdx>=0 ? main.slice(atIdx+1) : '';
          const host = hostPart.split(':')[0] || '';
          const port = hostPart.split(':')[1] || '';
          return `åç§°: ${tag}\nåè®®: trojan\næœåŠ¡å™¨: ${host}\nç«¯å£: ${port}\nå¯†ç : ${password}`;
        }

        // hysteria2 etc - è¿”å›åŸæ ·
        return url;
      } catch(e){
        return url;
      }
    }

    // ============ åè®®è¯†åˆ« / è§„èŒƒåŒ– / ç”Ÿæˆ ============
    function detectProtocol(node) {
      if (!node) return 'vless';
      if (typeof node === 'string') {
        const s = node.trim();
        if (s.startsWith('ss://')) return 'ss';
        if (s.startsWith('vmess://')) return 'vmess';
        if (s.startsWith('vless://')) return 'vless';
        if (s.startsWith('trojan://')) return 'trojan';
        if (s.startsWith('hysteria2://') || s.startsWith('hy2://')) return 'hy2';
      }
      if (node.type && node.type.toLowerCase() === 'ss') return 'ss';
      if (node.method && node.password) return 'ss';
      if (node.type && node.type.toLowerCase() === 'trojan') return 'trojan';
      if (node.type && node.type.toLowerCase() === 'vmess') return 'vmess';
      if (node.type && node.type.toLowerCase() === 'hysteria2') return 'hy2';
      if (node.uuid) return 'vless';
      return 'vless';
    }

    // å½“ node æ˜¯å­—ç¬¦ä¸²é“¾æ¥æ—¶ï¼Œå°è¯•è§£ææˆå¯¹è±¡ï¼ˆæ”¯æŒ ss:// vmess:// vless:// trojan://ï¼‰
    function parseNodeStringToObject(s){
      if (!s || typeof s !== 'string') return null;
      s = s.trim();
      try {
        if (s.startsWith('ss://')) {
          // è§£æ ss
          const without = s.slice(5);
          const hashSplit = without.split('#');
          const tag = decodeURIComponent(hashSplit[1] || '') || undefined;
          const main = hashSplit[0];
          let userEnc, hostPart;
          if (main.includes('@')) {
            [userEnc, hostPart] = main.split('@');
          } else {
            // main is base64 that decodes to user:pass@host:port
            const decoded = safeB64Decode(main);
            const atIdx = decoded.indexOf('@');
            if (atIdx === -1) return { raw: s };
            userEnc = safeB64Encode(decoded.slice(0, atIdx));
            hostPart = decoded.slice(atIdx+1);
          }
          const userinfo = safeB64Decode(userEnc);
          const [method, password] = userinfo.split(':');
          // hostPart may contain /?plugin=...
          let server = hostPart.split('/')[0];
          if (server.includes('?')) server = server.split('?')[0];
          const port = server.split(':')[1] || '';
          const host = server.split(':')[0] || '';
          return {
            name: tag,
            type: 'ss',
            server: host,
            port: port,
            password: password,
            method: method
          };
        }

        if (s.startsWith('vmess://')) {
          const b = s.slice(8);
          const json = safeB64Decode(b);
          try { return JSON.parse(json); } catch(e){ return { raw: s }; }
        }

        if (s.startsWith('vless://')) {
          return { raw: s }; // minimal handling
        }

        if (s.startsWith('trojan://')) {
          return { raw: s }; // minimal
        }
      } catch(e){
        return { raw: s };
      }
      return null;
    }

    function normalizeNode(node){
      // If node is a string that looks like a link, try to parse it into an object
      if (typeof node === 'string') {
        const parsed = parseNodeStringToObject(node);
        if (parsed) return parsed;
      }
      return {
        tag: node.name || node.tag || "æœªå‘½åèŠ‚ç‚¹",
        type: node.type || "vless",
        uuid: node.uuid || "",
        server: node.server || node.add || "",
        server_port: node.port || node.server_port || node.p || "",
        password: node.password || node.pass || "",
        // prefer method, then cipher (ss2022 often in cipher)
        method: node.method || node.cipher || "",
        security: node.tls?.enabled ? "tls" : (node.security || "none"),
        transport: {
          type: node.transport?.type || node.network || node.net || "tcp",
          path: node.transport?.path || node["ws-opts"]?.path || "",
          headers: node.transport?.headers || { Host: node.host || "" }
        },
        aid: node.aid || node.alterId || "0",
        flow: node.flow || "",
        tls: node.tls || {},
        plugin: node.plugin || "",
        plugin_opts: node.plugin_opts || ""
      };
    }

    function convertNode(input, tagOverride=""){
      let protocol = document.getElementById('protocol')?.value || "";
      if (!protocol) protocol = detectProtocol(input);
      let tag = tagOverride || document.getElementById('customTag')?.value.trim() || input.tag || input.name || "æœªå‘½åèŠ‚ç‚¹";
      let url = '';

      if (protocol === 'ss') {
        // method may contain ":" (ss2022 e.g. "2022-blake3-aes-256-gcm:KEY")
        const method = input.method || input.cipher || '';
        const password = input.password || input.pass || '';
        const userinfo = `${method}:${password}`;
        const base = safeB64Encode(userinfo);
        let pluginStr = '';
        if (input.plugin) {
          pluginStr = `/?plugin=${encodeURIComponent(input.plugin)}`;
          if (input.plugin_opts) pluginStr += `%3B${encodeURIComponent(input.plugin_opts)}`;
        }
        url = `ss://${base}@${input.server}:${input.server_port}${pluginStr}#${encodeURIComponent(tag)}`;
      }
      else if (protocol === 'vless') {
        let extra = '';
        if (input.flow) extra += `&flow=${input.flow}`;
        if (input.security === 'tls') {
          extra = `security=tls`;
          if (input.tls?.server_name) extra += `&sni=${input.tls.server_name}`;
        }
        if (extra.startsWith('&')) extra = extra.slice(1);
        url = `vless://${input.uuid}@${input.server}:${input.server_port}${extra?('?'+extra):''}#${encodeURIComponent(tag)}`;
      }
      else if (protocol === 'vmess') {
        const node = {
          v: "2",
          ps: tag,
          add: input.server,
          port: input.server_port,
          id: input.uuid,
          aid: input.aid || "0",
          net: input.transport?.type || "tcp",
          type: "none",
          host: input.transport?.headers?.Host || "",
          path: input.transport?.path || "/",
          tls: input.security || ""
        };
        url = `vmess://${safeB64Encode(JSON.stringify(node))}`;
      }
      else if (protocol === 'trojan') {
        url = `trojan://${input.password}@${input.server}:${input.server_port}#${encodeURIComponent(tag)}`;
      }
      else if (protocol === 'hy2') {
        url = `hysteria2://${input.password}@${input.server}:${input.server_port}/#${encodeURIComponent(tag)}`;
      }
      return url;
    }

    // ============ æ‰¹é‡è¾“å…¥è§£æï¼ˆæ›´é²æ£’ï¼‰ ============
    // å°è¯•æŠŠæ–‡æœ¬è§£æä¸ºæ•°ç»„å¯¹è±¡ï¼ˆæ”¯æŒ JSON æ•°ç»„ã€YAML åˆ—è¡¨ã€æ¯è¡Œå•ä¸ª JSONã€ä»¥ "- {...}" çš„ YAML åˆ—è¡¨ï¼‰
    function parseBatchTextToArray(text){
      text = text.trim();
      if (!text) return [];
      // 1) å°è¯•æ•´ä½“ JSON.parse
      try {
        const j = JSON.parse(text);
        if (Array.isArray(j)) return j;
        if (typeof j === 'object') return [j];
      } catch(e){}
      // 2) å°è¯• yaml.loadï¼ˆå¯ä»¥å¤„ç† - {...} çš„åˆ—è¡¨ï¼‰
      try {
        const y = jsyaml.load(text);
        if (Array.isArray(y)) return y;
        if (typeof y === 'object') return [y];
      } catch(e){}

      // 3) å°è¯•æŒ‰è¡Œæå–èŠ±æ‹¬å·å†…çš„ JSON å­ä¸²ï¼ˆå¤„ç† - {...} æˆ–æ¯è¡Œ {...}ï¼‰
      const objs = [];
      let i = 0;
      while (i < text.length) {
        // æ‰¾ä¸‹ä¸€ä¸ª '{'
        const start = text.indexOf('{', i);
        if (start === -1) break;
        let depth = 0;
        let j = start;
        let found = false;
        for (; j < text.length; j++) {
          if (text[j] === '{') depth++;
          else if (text[j] === '}') {
            depth--;
            if (depth === 0) { found = true; j++; break; }
          }
        }
        if (found) {
          const piece = text.slice(start, j);
          try {
            const parsed = JSON.parse(piece);
            objs.push(parsed);
          } catch (e) {
            // æœ€åå°è¯• yaml å•æ¡è§£æ
            try {
              const parsedYaml = jsyaml.load(piece);
              if (parsedYaml) objs.push(parsedYaml);
            } catch(e2) {
              // å¿½ç•¥æ— æ³•è§£æçš„ç‰‡æ®µ
            }
          }
          i = j;
        } else break;
      }
      if (objs.length) return objs;

      // 4) æŒ‰è¡Œé€è¡Œå°è¯•è§£æï¼ˆæ¯è¡Œå¯èƒ½æ˜¯ JSON æˆ– YAMLï¼‰
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        let l = line;
        if (l.startsWith('- ')) l = l.slice(2).trim();
        // å°è¯• JSON.parse
        try {
          const p = JSON.parse(l);
          objs.push(p);
          continue;
        } catch(e){}
        // å°è¯• YAML parse single line
        try {
          const p = jsyaml.load(l);
          if (p) objs.push(p);
          continue;
        } catch(e){}
        // å°è¯•è§£æä¸ºé“¾æ¥ï¼ˆss:// vmess:// ...ï¼‰
        if (l.startsWith('ss://') || l.startsWith('vmess://') || l.startsWith('vless://') || l.startsWith('trojan://')) {
          objs.push(l);
          continue;
        }
      }
      if (objs.length) return objs;

      // 5) æ— æ³•è§£æ
      throw new Error('æ— æ³•è¯†åˆ«æ‰¹é‡è¾“å…¥æ ¼å¼ï¼Œè¯·ç¡®è®¤æ˜¯ JSON æ•°ç»„ / YAML åˆ—è¡¨ / æ¯è¡Œ JSON æˆ– - {...} åˆ—è¡¨ã€‚');
    }

    // ============ ä¸»æµç¨‹ ============
    function processInput(){
      let text = document.getElementById('inputText').value.trim();
      if (!text) { alert('è¯·è¾“å…¥å†…å®¹ï¼'); return; }
      let node;
      try { node = JSON.parse(text); }
      catch {
        try { const parsed = jsyaml.load(text); node = Array.isArray(parsed)?parsed[0]:parsed; }
        catch {
          // å¦‚æœä»ç„¶æ— æ³•è§£æï¼Œå…è®¸ä¼ å…¥å•ä¸ªé“¾æ¥å­—ç¬¦ä¸²ï¼ˆå¦‚ ss://...ï¼‰
          node = text;
        }
      }
      const normalized = normalizeNode(node);
      const url = convertNode(normalized);
      document.getElementById('output').value = url;
      document.getElementById('preview').style.display = 'block';
      // å¦‚æœæ˜¯ ss é“¾æ¥ï¼Œå±•ç¤ºè§£æåçš„å‚æ•°ï¼ˆserver/port/method/passwordï¼‰ï¼Œå¦åˆ™å±•ç¤ºå¸¸è§„ parse
      document.getElementById('preview').textContent = parseNodeFromURL(url);
    }

    function processBatch(){
      let text = document.getElementById('batchInput').value.trim();
      if (!text) { alert('è¯·è¾“å…¥æ‰¹é‡èŠ‚ç‚¹ YAML/JSONï¼'); return; }
      let nodes;
      try {
        nodes = parseBatchTextToArray(text);
      } catch (e) {
        alert('æ‰¹é‡è¾“å…¥è§£æå¤±è´¥ï¼š' + e.message);
        return;
      }
      // normalize each (å¦‚æœæ˜¯é“¾æ¥å­—ç¬¦ä¸²ï¼ŒnormalizeNode ä¼šå°è¯•è§£æ)
      const normalizedArr = nodes.map(n => normalizeNode(n));
      const results = normalizedArr.map((n, idx) => convertNode(n, n.name || n.tag || (`èŠ‚ç‚¹${idx+1}`)));
      document.getElementById('batchOutput').value = results.join("\n\n");
      // batch preview: å¯¹ ss åšåè§£æå¹¶æ˜¾ç¤ºå‚æ•°ï¼Œå…¶ä»–åè®®æ˜¾ç¤ºè§£æä¿¡æ¯æˆ–åŸé“¾æ¥
      const previews = results.map(u => parseNodeFromURL(u));
      document.getElementById('batchPreview').style.display = 'block';
      document.getElementById('batchPreview').textContent = previews.join("\n\n");
    }

    function copyOutput(id){
      const output = document.getElementById(id);
      output.select();
      document.execCommand('copy');
      alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
    }

    function clearAll(){
      document.getElementById('inputText').value='';
      document.getElementById('protocol').value='';
      document.getElementById('customTag').value='';
      document.getElementById('output').value='';
      document.getElementById('preview').style.display='none';
    }

    function clearBatch(){
      document.getElementById('batchInput').value='';
      document.getElementById('batchOutput').value='';
      document.getElementById('batchPreview').style.display='none';
    }
  </script>
</body>
</html>
